"use strict";(self.webpackChunktgg_sredocs=self.webpackChunktgg_sredocs||[]).push([[717],{2266:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(4848),a=n(8453);const i={sidebar_position:2},o="Infrastructure Layering",s={id:"patterns/layering",title:"Infrastructure Layering",description:"In general, we've found the following practice of managing infrastructure in layers to work quite well. Many of our initial approaches to infrastructure management involved placing the entire configuration in a single layer, so that the network, data, and application were all deployed together. While it was convenient to have a single entrypoint for the entire application deployment (such as a single terraform apply), this approach exhibited a number of drawbacks, including:",source:"@site/docs/patterns/layering.md",sourceDirName:"patterns",slug:"/patterns/layering",permalink:"/docs/patterns/layering",draft:!1,unlisted:!1,editUrl:"https://github.com/broadinstitute/tgg-sredocs/tree/main/docs/patterns/layering.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Patterns",permalink:"/docs/category/patterns"},next:{title:"Configuration and Code",permalink:"/docs/patterns/configuration_and_code"}},l={},c=[{value:"Example layout of a multi-layer terraform repository",id:"example-layout-of-a-multi-layer-terraform-repository",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"infrastructure-layering",children:"Infrastructure Layering"}),"\n",(0,r.jsxs)(t.p,{children:["In general, we've found the following practice of managing infrastructure in layers to work quite well. Many of our initial approaches to infrastructure management involved placing the entire configuration in a single layer, so that the network, data, and application were all deployed together. While it was convenient to have a single entrypoint for the entire application deployment (such as a single ",(0,r.jsx)(t.code,{children:"terraform apply"}),"), this approach exhibited a number of drawbacks, including:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Coupling"}),": The applications were tightly coupled with things like the VPC configuration for the network they resided in."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Large Change Radius"}),": Changes to the application's infrastructure could impact the network, and vice versa."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Difficulty in Reuse"}),": It was difficult to reuse infrastructure components across different applications."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Difficulty in Testing"}),": It was difficult to deploy small test environments, as the entire stack had to be deployed together."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Instead, we've opted for breaking configuration out into the following layers:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Network Layer"}),": This layer contains the VPC, subnets, and other network resources."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Data Layer"}),": This layer contains databases, caches, storage buckets, and other data storage resources."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Application Layer"}),": This contains compute, managed service configuration, and IAM permissions for the application and its associated resources"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Breaking the configuration down into these three layers has worked well in several areas. From a dependency standpoint, the upper layers of the infrastructure are often dependent on the lower layers, and assuming that the lower levels are built first makes the upper layers easier to build. While tools like terraform are designed to resolve these dependencies, in practice, we found that it was often failing to wait for the lower level layers to be available before proceeding onto the upper layers. This resulted in inconsistent deployment success."}),"\n",(0,r.jsx)(t.p,{children:"By managing the infrastucture for the network, data, and application separately, we can enforce high level ordering (e.g. The network must be applied first, then data resources, and finally application resources). This allows the application deployment modules to be written in a way where they don't need to be concerned with the lower levels, which has reduced complexity. The rough high-level ordering has largely mitigated the problems terraform was having with eventually consistent cloud provider APIs."}),"\n",(0,r.jsx)(t.p,{children:"We've also found that these three layers are often developed at dramatically different speeds. The network layer changes quite rarely after initial development, as do the data layers. The application layer, however, changes quite frequently. By separating these layers, we can reduce the blast radius of changes, and make it easier to test and deploy changes to the application layer without impacting the network or data layers. It has also opened the door to more re-use of things like VPCs, as they are no longer managed with a particular application's deployment."}),"\n",(0,r.jsx)(t.h2,{id:"example-layout-of-a-multi-layer-terraform-repository",children:"Example layout of a multi-layer terraform repository"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"gcp-project-name/\n\u251c\u2500\u2500 vpc/\n\u2502   \u251c\u2500\u2500 main.tf # VPC configuration\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 cloudsql.tf # CloudSQL database\n\u2502   \u251c\u2500\u2500 redis.tf # Redis cache\n\u251c\u2500\u2500 services/ # individual application\n\u2502   \u251c\u2500\u2500 app1/\n\u2502   \u2502   \u251c\u2500\u2500 main.tf\n\u2502   \u251c\u2500\u2500 app2/\n\u2502   \u2502   \u251c\u2500\u2500 main.tf\n"})}),"\n",(0,r.jsx)(t.p,{children:"In the preceding example, you would deploy a fresh environment in the following order:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["in the ",(0,r.jsx)(t.code,{children:"vpc"})," directory, run ",(0,r.jsx)(t.code,{children:"terraform apply"})]}),"\n",(0,r.jsxs)(t.li,{children:["in the ",(0,r.jsx)(t.code,{children:"data"})," directory, run ",(0,r.jsx)(t.code,{children:"terraform apply"})]}),"\n",(0,r.jsxs)(t.li,{children:["in each of the ",(0,r.jsx)(t.code,{children:"services"})," directories, run ",(0,r.jsx)(t.code,{children:"terraform apply"})]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"With this directory structure in place, you can see how the opportunity is provided to independently update any of these components without affecting the others. As a smaller implementation detail, when using terraform, this also has the added benefit of limiting the size and scope of the state file. There's less risk of corrupting state outside of the small scope that you're currently changing, and smaller state files keep you from running into the maximum number of resources that can be managed in a single state file."}),"\n",(0,r.jsx)(t.p,{children:"Changes to the application can now also be made with less friction. With a smaller scope, it's much less likely that your change will be stuck behind changes that are in progress in other layers of the stack."})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var r=n(6540);const a={},i=r.createContext(a);function o(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);